// Generated by CoffeeScript 1.8.0
(function() {
  var njs_fs, njs_path,
    __slice = [].slice;

  njs_path = require('path');

  njs_fs = require('fs');

  this.names_in_folder = function(route, handler) {
    if (handler == null) {
      return njs_fs.readdirSync(route);
    }
    njs_fs.readdir(route, handler);
    return null;
  };

  this.locators_in_folder = function(route, handler) {
    var name;
    if (handler == null) {
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.names_in_folder(route);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          _results.push(njs_path.join(route, name));
        }
        return _results;
      }).call(this);
    }
    return this.names_in_folder(route, function(error, names) {
      if (error != null) {
        handler(error, null);
      }
      return handler(null, (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          _results.push(njs_path.join(route, name));
        }
        return _results;
      })());
    });
  };

  this.all_locators_in_folder = function(route, handler) {

    /* NOTE: this version does NOT follow symlinks!
     */
    var R, locator, _i, _len, _ref;
    if (handler == null) {
      R = [];
      _ref = this.locators_in_folder(route);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        locator = _ref[_i];
        R.push(locator);
        if ((njs_fs.lstatSync(locator)).isDirectory()) {
          R.splice.apply(R, [R.length, 0].concat(__slice.call(this.all_locators_in_folder(locator))));
        }
      }
      return R;
    }
    throw new Error('asynchronous FS/all-locators-in-folder not implemented');
  };

  this.get_date_of_newest_object_in_folder = function(route, handler) {

    /* NOTE: this version does NOT follow symlinks!
     */
    var R, locator, locators, _i, _len;
    if (handler == null) {
      locators = this.all_locators_in_folder(route);
      if (locators.length === 0) {
        throw new Error("no entries in folder " + route);
      }
      R = 0;
      for (_i = 0, _len = locators.length; _i < _len; _i++) {
        locator = locators[_i];
        R = Math.max((njs_fs.lstatSync(locator)).mtime * 1, R);
      }
      return new Date(R);
    }
    throw new Error('asynchronous FS/get-date-of-newest-object-in-folder not implemented');
  };

  this.get_timestamp_of_newest_object_in_folder = function(route, handler) {
    var R;
    if (handler == null) {
      R = (this.get_date_of_newest_object_in_folder(route)).toISOString();
      R = R.replace('T', '-');
      R = R.replace(/:/g, '-');
      R = R.replace(/\..*$/g, '');
      return R;
    }
    throw new Error('asynchronous FS/get-iso-timestamp-of-newest-object-in-folder not implemented');
  };

  this._safe_get_fs_stat = function(route, follow_links) {
    var error;
    if (follow_links == null) {
      follow_links = true;
    }
    try {
      if (follow_links) {
        return njs_fs.statSync(route);
      } else {
        return njs_fs.lstatSync(route);
      }
    } catch (_error) {
      error = _error;
      if ((error['message'].indexOf('ENOENT, no such file or directory ')) !== 0) {
        throw error;
      }
      return null;
    }
  };

  this.exists = function(route) {
    return (this._safe_get_fs_stat(route)) != null;
  };

  this.is_folder = function(route) {
    var stat;
    stat = this._safe_get_fs_stat(route);
    if (stat === null) {
      return false;
    }
    return stat.isDirectory();
  };

}).call(this);
