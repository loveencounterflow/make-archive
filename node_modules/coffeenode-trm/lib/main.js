// Generated by CoffeeScript 1.7.1
(function() {
  var ANALYZER, TYPES, badge, color_code, color_name, effect_name, effect_names, effect_off, effect_on, isa_text, lines_from_stdout, rainbow_color_names, rainbow_idx, _fn, _fn1, _ref, _rpr,
    __slice = [].slice;

  this.constants = require('./constants');

  this.separator = ' ';

  this.depth_of_inspect = 20;

  badge = 'TRM';

  TYPES = require('coffeenode-types');

  isa_text = TYPES.isa_text.bind(TYPES);

  _rpr = (require('util')).inspect;

  ANALYZER = require('./vt100-analyzer');

  this.rpr = function(x) {
    return _rpr(x, {
      depth: this.depth_of_inspect
    });
  };

  this.get_output_method = function(target, options) {
    return (function(_this) {
      return function() {
        var P;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return target.write(_this.pen.apply(_this, P));
      };
    })(this);
  };

  this.pen = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

    /* Given any number of arguments, return a text representing the arguments as seen fit for output
    commands like `log`, `echo`, and the colors.
     */
    return (this._pen.apply(this, P)).concat('\n');
  };

  this._pen = function() {
    var P, R, p;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

    /* ... */
    R = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = P.length; _i < _len; _i++) {
        p = P[_i];
        _results.push(isa_text(p) ? p : this.rpr(p));
      }
      return _results;
    }).call(this);
    return R.join(this.separator);
  };

  this.log = this.get_output_method(process.stderr);

  this.echo = this.get_output_method(process.stdout);

  this.listen_to_keys = function(handler) {

    /* thx to http://stackoverflow.com/a/12506613/256361 */

    /* try not to bind handler to same handler more than once: */
    var R, help, last_key_was_ctrl_c;
    if (handler.__TRM__listen_to_keys__is_registered) {
      return null;
    }
    Object.defineProperty(handler, '__TRM__listen_to_keys__is_registered', {
      value: true,
      enumerable: false
    });
    help = this.get_logger('help', badge);
    last_key_was_ctrl_c = false;
    R = process.openStdin();
    R.setRawMode(true);
    R.setEncoding('utf-8');
    R.resume();
    R.on('data', (function(_this) {
      return function(key) {
        var response;
        response = handler(key);
        if (key === '\u0003') {
          if (last_key_was_ctrl_c) {
            process.exit();
          }
          last_key_was_ctrl_c = true;
          return help("press ctrl-C again to exit");
        } else {
          return last_key_was_ctrl_c = false;
        }
      };
    })(this));
    return R;
  };

  this.ask = function(prompt, handler) {
    var rl;
    rl = (require('readline')).createInterface({
      input: process.stdin,
      output: process.stdout
    });
    if (!/\s+$/.test(prompt)) {
      prompt += ' ';
    }
    return rl.question(this.cyan(prompt), function(answer) {
      rl.close();
      return handler(null, answer);
    });
  };

  this.execute = function(command, handler) {
    var code, sh, stdout, _ref;
    if (handler == null) {

      /* https://github.com/mgutz/execSync
      NB `execSync` compiles with warnings under NodeJS 0.11.7 on my OSX box but appears to work, so let's
      pretend it won't be a problem for most people:
       */
      sh = require('execsync');
      _ref = sh.exec(command), code = _ref.code, stdout = _ref.stdout;
      if (code !== 0) {
        throw new Error(stdout);
      }
      return lines_from_stdout(stdout);
    }
    njs_cp.exec(O['on-change'], (function(_this) {
      return function(error, stdout, stderr) {
        if (error != null) {
          return handler(error);
        }
        if ((stderr != null) && stderr.length !== 0) {
          return handler(new Error(stderr));
        }
        return handler(null, lines_from_stdout(stdout));
      };
    })(this));
    return null;
  };

  lines_from_stdout = function(stdout) {
    var R;
    R = stdout.split('\n');
    if (R[R.length - 1].length === 0) {
      R.length -= 1;
    }
    return R;
  };

  this.clear_line_right = this.constants.clear_line_right;

  this.clear_line_left = this.constants.clear_line_left;

  this.clear_line = this.constants.clear_line;

  this.clear_below = this.constants.clear_below;

  this.clear_above = this.constants.clear_above;

  this.clear = this.constants.clear;

  this.goto = function(line_nr, column_nr) {
    if (line_nr == null) {
      line_nr = 1;
    }
    if (column_nr == null) {
      column_nr = 1;
    }
    return "\x1b[" + line_nr + ";" + column_nr + "H";
  };

  this.goto_column = function(column_nr) {
    if (column_nr == null) {
      column_nr = 1;
    }
    return "\x1b[" + column_nr + "G";
  };

  this.up = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "A";
  };

  this.down = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "B";
  };

  this.right = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "C";
  };

  this.left = function(count) {
    if (count == null) {
      count = 1;
    }
    return "\x1b[" + count + "D";
  };

  this.move = function(line_count, column_count) {
    return (line_count < 0 ? this.up(line_count) : this.down(line_count)) + (column_count < 0 ? this.left(column_count) : this.right(column_count));
  };

  this.ring_bell = function() {
    return process.stdout.write("\x07");
  };

  effect_names = {
    blink: 1,
    bold: 1,
    reverse: 1,
    underline: 1
  };

  _fn = (function(_this) {
    return function(effect_name, effect_on, effect_off) {
      return _this[effect_name] = function() {
        var P, R, idx, last_idx, p, _i, _len;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        R = [effect_on];
        last_idx = P.length - 1;
        for (idx = _i = 0, _len = P.length; _i < _len; idx = ++_i) {
          p = P[idx];
          R.push(isa_text(p) ? p : _this.rpr(p));
          if (idx !== last_idx) {
            R.push(effect_on);
            R.push(_this.separator);
          }
        }
        R.push(effect_off);
        return R.join('');
      };
    };
  })(this);
  for (effect_name in effect_names) {
    effect_on = this.constants[effect_name];
    effect_off = this.constants['no_' + effect_name];
    _fn(effect_name, effect_on, effect_off);
  }

  _ref = this.constants['colors'];
  _fn1 = (function(_this) {
    return function(color_name, color_code) {
      return _this[color_name] = function() {
        var P, R, idx, last_idx, p, _i, _len;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        R = [color_code];
        last_idx = P.length - 1;
        for (idx = _i = 0, _len = P.length; _i < _len; idx = ++_i) {
          p = P[idx];
          R.push(isa_text(p) ? p : _this.rpr(p));
          if (idx !== last_idx) {
            R.push(color_code);
            R.push(_this.separator);
          }
        }
        R.push(_this.constants['reset']);
        return R.join('');
      };
    };
  })(this);
  for (color_name in _ref) {
    color_code = _ref[color_name];
    _fn1(color_name, color_code);
  }

  this.remove_colors = function(text) {
    return text.replace(this.color_matcher, '');
  };

  this.color_matcher = /\x1b\[[^m]*m/g;

  rainbow_color_names = "red orange yellow green blue pink".split(/\s+/);

  rainbow_idx = -1;

  this.rainbow = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    rainbow_idx = (rainbow_idx + 1) % rainbow_color_names.length;
    return this[rainbow_color_names[rainbow_idx]].apply(this, P);
  };

  this.route = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.lime(this.underline.apply(this, P));
  };

  this.truth = function() {
    var P, p;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = P.length; _i < _len; _i++) {
        p = P[_i];
        _results.push(p ? this.green("✔  " + (this._pen(p))) : this.red("✗  " + (this._pen(p))));
      }
      return _results;
    }).call(this)).join('');
  };

  this.get_logger = function(category, badge) {
    var R, colorize, pointer, prefix;
    if (badge == null) {
      badge = null;
    }
    switch (category) {
      case 'plain':
        colorize = null;
        pointer = this.grey(' ▶ ');
        break;
      case 'info':
        colorize = this.BLUE.bind(this);
        pointer = this.grey(' ▶ ');
        break;
      case 'whisper':
        colorize = this.grey.bind(this);
        pointer = this.grey(' ▶ ');
        break;
      case 'urge':
        colorize = this.orange.bind(this);
        pointer = this.bold(this.RED(' ? '));
        break;
      case 'praise':
        colorize = this.GREEN.bind(this);
        pointer = this.GREEN(' ✔ ');
        break;
      case 'debug':
        colorize = this.pink.bind(this);
        pointer = this.grey(' ⚙ ');
        break;
      case 'alert':
        colorize = this.RED.bind(this);
        pointer = this.blink(this.RED(' ⚠ '));
        break;
      case 'warn':
        colorize = this.RED.bind(this);
        pointer = this.bold(this.RED(' ! '));
        break;
      case 'help':
        colorize = this.lime.bind(this);
        pointer = this.gold(' ☛ ');
        break;
      default:
        throw new Error("unknown logger category " + (_rpr(category)));
    }
    prefix = badge != null ? (this.darkgrey(badge)).concat(' ', pointer) : pointer;
    if (colorize != null) {
      R = (function(_this) {
        return function() {
          var P;
          P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.log(prefix, colorize.apply(null, P));
        };
      })(this);
    } else {
      R = (function(_this) {
        return function() {
          var P;
          P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.log.apply(_this, [prefix].concat(__slice.call(P)));
        };
      })(this);
    }
    return R;
  };


  /* TAINT naming unstable, to be renamed */

  this.as_html = ANALYZER.as_html.bind(ANALYZER);

  this.get_css_source = ANALYZER.get_css_source.bind(ANALYZER);

  this.analyze = ANALYZER.analyze.bind(ANALYZER);

  this.clean = function(text) {
    var R, chunk, is_ansicode;
    is_ansicode = true;
    R = [];
    return ((function() {
      var _i, _len, _ref1, _results;
      _ref1 = this.analyze(text);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        chunk = _ref1[_i];
        if ((is_ansicode = !is_ansicode)) {
          _results.push(chunk);
        }
      }
      return _results;
    }).call(this)).join('');
  };

  this._prototype_of_object = Object.getPrototypeOf(new Object());

  this._dir_options = {
    'skip-list-idxs': true,
    'skip-object': true
  };

  this._marker_by_type = {
    'function': '()'
  };

  this.dir = function() {
    var P, arity, idx, p, r, width, x, _i, _len;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    switch (arity = P.length) {
      case 0:
        throw new Error("called TRM.dir without arguments");
        break;
      case 1:
        x = P[0];
        break;
      default:
        x = P[P.length - 1];
        for (idx = _i = 0, _len = P.length; _i < _len; idx = ++_i) {
          p = P[idx];
          if (idx < P.length - 1) {
            this.log(this.rainbow(p));
          }
        }
    }
    width = process.stdout.isTTY ? process.stdout.columns : 108;
    r = (this.rpr(x)).replace(/\n\s*/g, ' ');
    if (r.length > width) {
      r = r.slice(0, +Math.max(5, width - 5) + 1 || 9e9).concat(this.grey(' ...'));
    }
    return this.log('\n'.concat(this.lime(r), '\n', (this._dir(x)).join(this.grey(' ')), '\n'));
  };

  this._dir = function(x) {
    var R, marker, name, names, p, role, type, _i, _j, _len, _len1, _ref1, _ref2;
    R = [];
    _ref1 = this._get_prototypes_types_and_property_names(x, []);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      _ref2 = _ref1[_i], role = _ref2[0], p = _ref2[1], type = _ref2[2], names = _ref2[3];
      R.push(this.grey('('.concat(role, ')')));
      R.push(this.orange(type));
      for (_j = 0, _len1 = names.length; _j < _len1; _j++) {
        name = names[_j];
        marker = this._marker_from_type(TYPES.type_of((Object.getOwnPropertyDescriptor(p, name))['value']));
        R.push((this.cyan(name)).concat(this.grey(marker)));
      }
    }
    return R;
  };

  this._is_list_idx = function(idx_txt, length) {
    var _ref1;
    if (!/^[0-9]+$/.test(idx_txt)) {
      return false;
    }
    return (0 <= (_ref1 = parseInt(idx_txt)) && _ref1 < length);
  };

  this._marker_from_type = function(type) {
    var _ref1;
    return (_ref1 = this._marker_by_type[type]) != null ? _ref1 : '|'.concat(type);
  };

  this._get_prototypes_types_and_property_names = function(x, types_and_names) {
    var error, length, name, names, prototype, role, x_;
    role = types_and_names.length === 0 ? 'type' : 'prototype';
    if (x == null) {
      types_and_names.push([role, x, TYPES.type_of(x), []]);
      return types_and_names;
    }
    try {
      names = Object.getOwnPropertyNames(x);
      prototype = Object.getPrototypeOf(x);
    } catch (_error) {
      error = _error;
      if (error['message'] !== 'Object.getOwnPropertyNames called on non-object') {
        throw error;
      }
      x_ = new Object(x);
      names = Object.getOwnPropertyNames(x_);
      prototype = Object.getPrototypeOf(x_);
    }
    try {
      length = x.length;
      if (length != null) {
        names = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            if (!this._is_list_idx(name, x.length)) {
              _results.push(name);
            }
          }
          return _results;
        }).call(this);
      }
    } catch (_error) {
      error = _error;
      if (!error['message'].test(/^Cannot read property 'length' of /)) {
        throw error;
      }
    }
    names.sort();
    types_and_names.push([role, x, TYPES.type_of(x), names]);
    if ((prototype != null) && !(this._dir_options['skip-object'] && prototype === this._prototype_of_object)) {
      this._get_prototypes_types_and_property_names(prototype, types_and_names);
    }
    return types_and_names;
  };

}).call(this);
