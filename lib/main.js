// Generated by CoffeeScript 1.9.0
(function() {
  var ASYNC, CND, FS, alert, badge, debug, dryrun, echo, fat_ruler, glob, help, host_name, info, log, njs_fs, njs_os, njs_path, njs_spawn, options, project_locators, rpr, ruler, urge, warn, whisper, _ref,
    __slice = [].slice;

  njs_path = require('path');

  njs_os = require('os');

  njs_spawn = (require('child_process')).spawn;


  /* TAINT temporary solution; should unify the two */

  njs_fs = require('fs-extra');

  FS = require('./FS');

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'make-archive';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  ruler = (new Array(108)).join('─');

  fat_ruler = (new Array(108)).join('━');

  ASYNC = require('async');

  glob = require('glob');

  host_name = njs_os.hostname();

  host_name = host_name.replace('.fritz.box', '');

  project_locators = process.argv.slice(2);

  options = require('../options');

  dryrun = (_ref = options['dryrun']) != null ? _ref : false;

  this.main = function() {
    var archive_exists, archive_home, archive_locator, archive_name, backup_glob, backup_home, backup_homes, command_and_arguments, existing_backups, idx, is_folder, primary_output_home, primary_tasks, project_home, project_locator, project_name, secondary_output_homes, surplus_count, timestamp, _fn, _i, _j, _k, _l, _len, _len1, _len2, _ref1;
    if (project_locators.length === 0) {
      throw new Error("must give at least one project locator");
    }
    backup_homes = [];
    primary_tasks = [];
    _ref1 = options['output-homes'], primary_output_home = _ref1[0], secondary_output_homes = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
    this.validate_route_is_folder(primary_output_home);
    info();
    whisper(fat_ruler);
    info('COFFEENODE Backup Utility');
    whisper(ruler);
    for (_i = 0, _len = secondary_output_homes.length; _i < _len; _i++) {
      backup_home = secondary_output_homes[_i];
      if (is_folder = FS.is_folder(backup_home)) {
        backup_homes.push(backup_home);
      }
      help('backup folder:        ', backup_home, CND.truth(is_folder));
    }
    _fn = (function(_this) {
      return function(project_locator, archive_name, archive_locator, command_and_arguments) {
        return primary_tasks.push(function(primary_handler) {
          return _this.spawn.apply(_this, __slice.call(command_and_arguments).concat([function(error) {
            var secondary_tasks, _fn1, _k, _len2;
            if (error != null) {
              return primary_handler(error);
            }
            if (backup_homes.length === 0) {
              return primary_handler(null);
            }
            secondary_tasks = [];
            _fn1 = function(backup_home) {
              return secondary_tasks.push(function(secondary_handler) {
                var backup_locator;
                backup_locator = njs_path.join(backup_home, archive_name);
                return _this.copy_with_rsync(archive_locator, backup_locator, secondary_handler);
              });
            };
            for (_k = 0, _len2 = backup_homes.length; _k < _len2; _k++) {
              backup_home = backup_homes[_k];
              _fn1(backup_home);
            }
            return ASYNC.parallelLimit(secondary_tasks, 5, function(error) {
              return primary_handler(error);
            });
          }]));
        });
      };
    })(this);
    for (_j = 0, _len1 = project_locators.length; _j < _len1; _j++) {
      project_locator = project_locators[_j];
      project_locator = (FS.resolve_route(project_locator)).replace(/\/+$/, '');
      this.validate_route_is_folder(project_locator);
      project_name = njs_path.basename(project_locator);
      project_home = njs_path.dirname(project_locator);
      this.validate_name(project_name);
      timestamp = FS.get_timestamp_of_newest_object_in_folder(project_locator);
      archive_name = project_name + "_" + timestamp + ".dmg";
      archive_home = njs_path.join(primary_output_home, project_name);
      archive_locator = njs_path.join(archive_home, archive_name);
      this.ensure_route_is_folder(archive_home);
      archive_exists = FS.exists(archive_locator);
      whisper(ruler);
      help('project-name:         ', project_name);
      help('project-locator:      ', project_locator);
      help('archive-locator:      ', archive_locator);
      help('archive-exists:       ', CND.truth(archive_exists));
      for (_k = 0, _len2 = backup_homes.length; _k < _len2; _k++) {
        backup_home = backup_homes[_k];
        backup_glob = njs_path.join(backup_home, project_name + "_*.dmg");
        help('backup folder:        ', backup_home);
        existing_backups = glob.sync(backup_glob);
        surplus_count = Math.max(0, existing_backups.length - options['max-backup-count']);
        if (!archive_exists) {
          surplus_count += +1;
        }
        surplus_count = Math.min(surplus_count, existing_backups.length);
        help("There are " + existing_backups.length + " backups of this archive in " + backup_home);
        if (surplus_count > 0) {
          warn(surplus_count + " of which will be removed");
          for (idx = _l = 0; 0 <= surplus_count ? _l < surplus_count : _l > surplus_count; idx = 0 <= surplus_count ? ++_l : --_l) {
            warn("removing " + existing_backups[idx]);
            if (!dryrun) {
              njs_fs.unlinkSync(existing_backups[idx]);
            }
          }
        }
      }
      if (archive_exists) {
        continue;
      }
      command_and_arguments = this.get_archiving_command_and_arguments(project_locator, archive_locator);
      _fn(project_locator, archive_name, archive_locator, command_and_arguments);
    }
    return ASYNC.series(primary_tasks, function(error, results) {
      if (error != null) {
        throw error;
      }
      whisper(fat_ruler);
      return help('All tasks have finished.');
    });
  };

  this.validate_route = function(route) {
    if ((Object.prototype.toString.call(route)) !== '[object String]') {
      throw new Error("expected a text as route");
    }
    if (route.length === 0) {
      throw new Error("expected a non-empty text as route");
    }
    if ((route.match(/[\s:"'\\<>|]/)) !== null) {
      throw new Error("illegal route: " + (rpr(route)));
    }
    return null;
  };

  this.validate_name = function(name) {
    if ((Object.prototype.toString.call(name)) !== '[object String]') {
      throw new Error("expected a text as name");
    }
    if (name.length === 0) {
      throw new Error("expected a non-empty text as name");
    }
    if ((name.match(/[\s:"'\\<>|\/]/)) !== null) {
      throw new Error("illegal name: " + (rpr(name)));
    }
    return null;
  };

  this.validate_route_is_folder = function(route) {
    var _ref1;
    this.validate_route(route);
    if (!FS.is_folder(route)) {
      if (!((_ref1 = options['create-folder']) != null ? _ref1 : true)) {
        this.complain("route " + (rpr(route)) + " must point to existing folder");
      }
    }
    return null;
  };

  this.ensure_route_is_folder = function(route) {
    var _ref1;
    this.validate_route(route);
    if (!FS.is_folder(route)) {
      if (!((_ref1 = options['create-folder']) != null ? _ref1 : true)) {
        this.complain("route " + (rpr(route)) + " must point to existing folder");
      }
      if (FS.exists(route)) {
        this.complain("route " + (rpr(route)) + " points to existing file");
      }
      FS.mkdirp(route);
      help("created folder at " + route);
    }
    return null;
  };

  this.validate_route_doesnt_exist = function(route) {
    this.validate_route(route);
    if (FS.exists(route)) {
      throw new Error("route " + (rpr(route)) + " already exists");
    }
    return null;
  };

  this.validate_archive_format = function(format) {
    if ((Object.prototype.toString.call(format)) !== '[object String]') {
      throw new Error("expected a text as format");
    }
    switch (format) {
      case 'UDRW':
      case 'UDRO':
      case 'UDCO':
      case 'UDZO':
      case 'UDBZ':
      case 'UFBI':
      case 'UDTO':
      case 'UDxx':
      case 'UDSP':
      case 'UDSB':
        null;
        break;
      default:
        throw new Error("unknown format " + (rpr(format)));
    }
    return null;
  };

  this.complain = function(message) {
    warn(message);
    return process.exit();
  };

  this.get_archiving_command_and_arguments = function(project_locator, archive_locator) {

    /* thx to http://qntm.org/bash
     */
    var archive_format, arguments_, command, volume_name;
    volume_name = (njs_path.basename(archive_locator)).replace(/\..*$/, '');
    archive_format = options['archive-format'];
    this.validate_archive_format(archive_format);
    command = 'hdiutil';
    arguments_ = ['create', '-format', archive_format, '-srcfolder', project_locator, '-volname', volume_name, archive_locator];
    return [command, arguments_];
  };

  this.copy_with_rsync = function(archive_locator, backup_locator, handler) {
    help("using rsync to copy");
    help("  from " + archive_locator);
    help("  to   " + backup_locator);
    return this.spawn.apply(this, __slice.call(this.get_copy_command_and_arguments(archive_locator, backup_locator)).concat([(function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        help('ok');
        return handler(null);
      };
    })(this)]));
  };

  this.get_copy_command_and_arguments = function(archive_locator, backup_locator) {
    var arguments_, command;
    command = 'rsync';
    arguments_ = ['-av', '--progress', archive_locator, backup_locator];
    return [command, arguments_];
  };

  if (dryrun) {
    warn("dryrun");
    this.spawn = function(command, arguments_, handler) {
      whisper(fat_ruler);
      whisper(command + ' ' + arguments_.join(' '));
      handler(null, null);
      return null;
    };
  } else {
    this.spawn = function(command, arguments_, handler) {
      var R;
      whisper(fat_ruler);
      whisper(command + ' ' + arguments_.join(' '));
      R = njs_spawn(command, arguments_, {
        stdio: 'inherit'
      });
      R.on('close', (function(_this) {
        return function(code) {
          return handler(null, null);
        };
      })(this));
      return R;
    };
  }


  /*
  #===========================================================================================================
  
  
  
   .d8888b.  888      8888888
  d88P  Y88b 888        888
  888    888 888        888
  888        888        888
  888        888        888
  888    888 888        888
  Y88b  d88P 888        888
   "Y8888P"  88888888 8888888
  
  
  
  #===========================================================================================================
   */

  this.cli = function() {
    var cli_options, docopt, filename, settings, usage, version;
    docopt = (require('coffeenode-docopt')).docopt;
    version = (require('../package.json'))['version'];
    filename = (require('path')).basename(__filename);
    usage = "Usage: " + filename + " <project-locators>...\n\nOptions:\n  -h, --help\n  -v, --version";
    cli_options = docopt(usage, {
      version: version,
      help: function(left, collected) {
        return help('\n' + usage);
      }
    });
    settings = {};
    settings['project-locators'] = cli_options['<project-locators>'];
    return this.main();
  };

  if (module.parent == null) {
    this.cli();
  }

}).call(this);
